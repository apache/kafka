<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at
 
    http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

Kafka uses key-value pairs in the <a href="http://en.wikipedia.org/wiki/.properties">property file format</a> for configuration. These values can be supplied either from a file or programmatically.

<h3><a id="brokerconfigs">3.1 Broker Configs</a></h3>

The essential configurations are the following:
<ul>
    <li><code>broker.id</code>
    <li><code>log.dirs</code>
    <li><code>zookeeper.connect</code>
</ul>

Topic-level configurations and defaults are discussed in more detail <a href="#topic-config">below</a>.

<table class="data-table">
<tbody><tr>
      <th>Property</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>broker.id</td>
      <td></td>
      <td>Each broker is uniquely identified by a non-negative integer id. This id serves as the broker's "name" and allows the broker to be moved to a different host/port without confusing consumers. You can choose any number you like so long as it is unique.
    </td>
    </tr>
    <tr>
      <td>log.dirs</td>
      <td nowrap>/tmp/kafka-logs</td>
      <td>A comma-separated list of one or more directories in which Kafka data is stored. Each new partition that is created will be placed in the directory which currently has the fewest partitions.</td>
    </tr>
    <tr>
      <td>port</td>
      <td>9092</td>
      <td>The port on which the server accepts client connections.</td>
    </tr>
    <tr>
      <td>zookeeper.connect</td>
      <td>null</td>
      <td>Specifies the ZooKeeper connection string in the form <code>hostname:port</code>, where hostname and port are the host and port for a node in your ZooKeeper cluster. To allow connecting through other ZooKeeper nodes when that host is down you can also specify multiple hosts in the form <code>hostname1:port1,hostname2:port2,hostname3:port3</code>.
    <p>
ZooKeeper also allows you to add a "chroot" path which will make all kafka data for this cluster appear under a particular path. This is a way to setup multiple Kafka clusters or other applications on the same ZooKeeper cluster. To do this give a connection string in the form <code>hostname1:port1,hostname2:port2,hostname3:port3/chroot/path</code> which would put all this cluster's data under the path <code>/chroot/path</code>. Note that consumers must use the same connection string.</td>
    </tr>
    <tr>
      <td>message.max.bytes</td>
      <td>1000000</td>
      <td>The maximum size of a message that the server can receive. It is important that this property be in sync with the maximum fetch size your consumers use or else an unruly producer will be able to publish messages too large for consumers to consume.</td>
    </tr>
    <tr>
      <td>num.network.threads</td>
      <td>3</td>
      <td>The number of network threads that the server uses for handling network requests. You probably don't need to change this.</td>
    </tr>
    <tr>
      <td>num.io.threads</td>
      <td>8</td>
      <td>The number of I/O threads that the server uses for executing requests. You should have at least as many threads as you have disks.</td>
    </tr>
    <tr>
      <td>background.threads</td>
      <td>10</td>
      <td>The number of threads to use for various background processing tasks such as file deletion. You should not need to change this.</td>
    </tr>
    <tr>
      <td>queued.max.requests</td>
      <td>500</td>
      <td>The number of requests that can be queued up for processing by the I/O threads before the network threads stop reading in new requests.</td>
    </tr>
    <tr>
      <td>host.name</td>
      <td>null</td>
      <td>
        <p>Hostname of broker. If this is set, it will only bind to this address. If this is not set, it will bind to all interfaces, and publish one to ZK.</p>
     </td>
    </tr>
    <tr>
      <td>advertised.host.name</td>
      <td>null</td>
      <td>
        <p>If this is set this is the hostname that will be given out to producers, consumers, and other brokers to connect to.</p>
     </td>
    </tr>
    <tr>
      <td>advertised.port</td>
      <td>null</td>
      <td>
        <p>The port to give out to producers, consumers, and other brokers to use in establishing connections. This only needs to be set if this port is different from the port the server should bind to.</p>
     </td>
    </tr>
    <tr>
      <td>socket.send.buffer.bytes</td>
      <td>100 * 1024</td>
      <td>The SO_SNDBUFF buffer the server prefers for socket connections.</td>
    </tr>
    <tr>
      <td>socket.receive.buffer.bytes</td>
      <td>100 * 1024</td>
      <td>The SO_RCVBUFF buffer the server prefers for socket connections.</td>
    </tr>
    <tr>
      <td>socket.request.max.bytes</td>
      <td>100 * 1024 * 1024</td>
      <td>The maximum request size the server will allow. This prevents the server from running out of memory and should be smaller than the Java heap size.</td>
    </tr>
    <tr>
      <td>num.partitions</td>
      <td>1</td>
      <td>The default number of partitions per topic if a partition count isn't given at topic creation time.</td>
    </tr>
    <tr>
      <td>log.segment.bytes</td>
      <td nowrap>1024 * 1024 * 1024</td>
      <td>The log for a topic partition is stored as a directory of segment files. This setting controls the size to which a segment file will grow before a new segment is rolled over in the log. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.roll.{ms,hours}</td>
      <td>24 * 7 hours</td>
      <td>This setting will force Kafka to roll a new log segment even if the log.segment.bytes size has not been reached. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.cleanup.policy</td>
      <td>delete</td>
      <td>This can take either the value <i>delete</i> or <i>compact</i>. If <i>delete</i> is set, log segments will be deleted when they reach the size or time limits set. If <i>compact</i> is set <a href="#compaction">log compaction</a> will be used to clean out obsolete records. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.retention.{ms,minutes,hours}</td>
      <td>7 days</td>
      <td>The amount of time to keep a log segment before it is deleted, i.e. the default data retention window for all topics. Note that if both log.retention.minutes and log.retention.bytes are both set we delete a segment when either limit is exceeded. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.retention.bytes</td>
      <td>-1</td>
      <td>The amount of data to retain in the log for each topic-partitions. Note that this is the limit per-partition so multiply by the number of partitions to get the total data retained for the topic. Also note that if both log.retention.hours and log.retention.bytes are both set we delete a segment when either limit is exceeded. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.retention.check.interval.ms</td>
      <td>5 minutes</td>
      <td>The period with which we check whether any log segment is eligible for deletion to meet the retention policies.</td>
    </tr>
    <tr>
      <td>log.cleaner.enable</td>
      <td>false</td>
      <td>This configuration must be set to true for log compaction to run.</td>
    </tr>
    <tr>
      <td>log.cleaner.threads</td>
      <td>1</td>
      <td>The number of threads to use for cleaning logs in log compaction.</td>
    </tr>
    <tr>
      <td>log.cleaner.io.max.bytes.per.second</td>
      <td>Double.MaxValue</td>
      <td>The maximum amount of I/O the log cleaner can do while performing log compaction. This setting allows setting a limit for the cleaner to avoid impacting live request serving.</td>
    </tr>
    <tr>
      <td>log.cleaner.dedupe.buffer.size</td>
      <td>500*1024*1024</td>
      <td>The size of the buffer the log cleaner uses for indexing and deduplicating logs during cleaning. Larger is better provided you have sufficient memory.</td>
    </tr>
    <tr>
      <td>log.cleaner.io.buffer.size</td>
      <td>512*1024</td>
      <td>The size of the I/O chunk used during log cleaning. You probably don't need to change this.</td>
    </tr>
    <tr>
      <td>log.cleaner.io.buffer.load.factor</td>
      <td>0.9</td>
      <td>The load factor of the hash table used in log cleaning. You probably don't need to change this.</td>
    </tr>
    <tr>
      <td>log.cleaner.backoff.ms</td>
      <td>15000</td>
      <td>The interval between checks to see if any logs need cleaning.</td>
    </tr>
    <tr>
      <td>log.cleaner.min.cleanable.ratio</td>
      <td>0.5</td>
      <td>This configuration controls how frequently the log compactor will attempt to clean the log (assuming <a href="#compaction">log compaction</a> is enabled). By default we will avoid cleaning a log where more than 50% of the log has been compacted. This ratio bounds the maximum space wasted in the log by duplicates (at 50% at most 50% of the log could be duplicates). A higher ratio will mean fewer, more efficient cleanings but will mean more wasted space in the log. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.cleaner.delete.retention.ms</td>
      <td>1 day</td>
      <td>The amount of time to retain delete tombstone markers for <a href="#compaction">log compacted</a> topics. This setting also gives a bound on the time in which a consumer must complete a read if they begin from offset 0 to ensure that they get a valid snapshot of the final stage (otherwise delete tombstones may be collected before they complete their scan). This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.index.size.max.bytes</td>
      <td>10 * 1024 * 1024</td>
      <td>The maximum size in bytes we allow for the offset index for each log segment. Note that we will always pre-allocate a sparse file with this much space and shrink it down when the log rolls. If the index fills up we will roll a new log segment even if we haven't reached the log.segment.bytes limit. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>log.index.interval.bytes</td>
      <td>4096</td>
      <td>The byte interval at which we add an entry to the offset index. When executing a fetch request the server must do a linear scan for up to this many bytes to find the correct position in the log to begin and end the fetch. So setting this value to be larger will mean larger index files (and a bit more memory usage) but less scanning. However the server will never add more than one index entry per log append (even if more than log.index.interval worth of messages are appended). In general you probably don't need to mess with this value.</td>
    </tr>
    <tr>
      <td>log.flush.interval.messages</td>
      <td>Long.MaxValue</td>
      <td>The number of messages written to a log partition before we force an fsync on the log. Setting this lower will sync data to disk more often but will have a major impact on performance. We generally recommend that people make use of replication for durability rather than depending on single-server fsync, however this setting can be used to be extra certain.</td>
    </tr>
    <tr>
      <td>log.flush.scheduler.interval.ms</td>
      <td>Long.MaxValue</td>
      <td>The frequency in ms that the log flusher checks whether any log is eligible to be flushed to disk.</td>
    </tr>
    <tr>
      <td>log.flush.interval.ms</td>
      <td>Long.MaxValue</td>
      <td>The maximum time between fsync calls on the log. If used in conjuction with log.flush.interval.messages the log will be flushed when either criteria is met.</td>
    </tr>
    <tr>
      <td>log.delete.delay.ms</td>
      <td>60000</td>
      <td>The period of time we hold log files around after they are removed from the in-memory segment index. This period of time allows any in-progress reads to complete uninterrupted without locking. You generally don't need to change this.</td>
    </tr>
    <tr>
      <td>log.flush.offset.checkpoint.interval.ms</td>
      <td>60000</td>
      <td>The frequency with which we checkpoint the last flush point for logs for recovery. You should not need to change this.</td>
    </tr>
    <tr>
      <td>log.segment.delete.delay.ms</td>
      <td>60000</td>
      <td>the amount of time to wait before deleting a file from the filesystem.</td>
    </tr>
    <tr>
      <td>auto.create.topics.enable</td>
      <td>true</td>
      <td>Enable auto creation of topic on the server.  If this is set to true then attempts to produce data or fetch metadata for a non-existent topic will automatically create it with the default replication factor and number of partitions.</td>
    </tr>
    <tr>
      <td>controller.socket.timeout.ms</td>
      <td>30000</td>
      <td>The socket timeout for commands from the partition management controller to the replicas.</td>
    </tr>
    <tr>
      <td>controller.message.queue.size</td>
      <td>Int.MaxValue</td>
      <td>The buffer size for controller-to-broker-channels</td>
    </tr>
    <tr>
      <td>default.replication.factor</td>
      <td>1</td>
      <td>The default replication factor for automatically created topics.</td>
    </tr>
    <tr>
      <td>replica.lag.time.max.ms</td>
      <td>10000</td>
      <td>If a follower hasn't sent any fetch requests for this window of time, the leader will remove the follower from ISR (in-sync replicas) and treat it as dead.</td>
    </tr>
    <tr>
      <td>replica.socket.timeout.ms</td>
      <td>30 * 1000</td>
      <td>The socket timeout for network requests to the leader for replicating data.</td>
    </tr>
    <tr>
      <td>replica.socket.receive.buffer.bytes</td>
      <td>64 * 1024</td>
      <td>The socket receive buffer for network requests to the leader for replicating data.</td>
    </tr>
    <tr>
      <td>replica.fetch.max.bytes</td>
      <td nowrap>1024 * 1024</td>
      <td>The number of byes of messages to attempt to fetch for each partition in the fetch requests the replicas send to the leader.</td>
    </tr>
    <tr>
      <td>replica.fetch.wait.max.ms</td>
      <td>500</td>
      <td>The maximum amount of time to wait time for data to arrive on the leader in the fetch requests sent by the replicas to the leader.</td>
    </tr>
    <tr>
      <td>replica.fetch.min.bytes</td>
      <td>1</td>
      <td>Minimum bytes expected for each fetch response for the fetch requests from the replica to the leader. If not enough bytes, wait up to replica.fetch.wait.max.ms for this many bytes to arrive.</td>
    </tr>
    <tr>
      <td>num.replica.fetchers</td>
      <td>1</td>
      <td>
        <p>Number of threads used to replicate messages from leaders. Increasing this value can increase the degree of I/O parallelism in the follower broker.</p>
     </td>
    </tr>
    <tr>
      <td>replica.high.watermark.checkpoint.interval.ms</td>
      <td>5000</td>
      <td>The frequency with which each replica saves its high watermark to disk to handle recovery.</td>
    </tr>
    <tr>
      <td>fetch.purgatory.purge.interval.requests</td>
      <td>1000</td>
      <td>The purge interval (in number of requests) of the fetch request purgatory.</td>
    </tr>
    <tr>
      <td>producer.purgatory.purge.interval.requests</td>
      <td>1000</td>
      <td>The purge interval (in number of requests) of the producer request purgatory.</td>
    </tr>
    <tr>
      <td>zookeeper.session.timeout.ms</td>
      <td>6000</td>
      <td>ZooKeeper session timeout. If the server fails to heartbeat to ZooKeeper within this period of time it is considered dead. If you set this too low the server may be falsely considered dead; if you set it too high it may take too long to recognize a truly dead server.</td>
    </tr>
    <tr>
      <td>zookeeper.connection.timeout.ms</td>
      <td>6000</td>
      <td>The maximum amount of time that the client waits to establish a connection to zookeeper.</td>
    </tr>
    <tr>
      <td>zookeeper.sync.time.ms</td>
      <td>2000</td>
      <td>How far a ZK follower can be behind a ZK leader.</td>
    </tr>
    <tr>
      <td>controlled.shutdown.enable</td>
      <td>true</td>
      <td>Enable controlled shutdown of the broker. If enabled, the broker will move all leaders on it to some other brokers before shutting itself down. This reduces the unavailability window during shutdown.</td>
    </tr>
    <tr>
      <td>controlled.shutdown.max.retries</td>
      <td>3</td>
      <td>Number of retries to complete the controlled shutdown successfully before executing an unclean shutdown.</td>
    </tr>
    <tr>
      <td>controlled.shutdown.retry.backoff.ms</td>
      <td>5000</td>
      <td>Backoff time between shutdown retries.</td>
    </tr>
    <tr>
      <td>auto.leader.rebalance.enable</td>
      <td>true</td>
      <td>If this is enabled the controller will automatically try to balance leadership for partitions among the brokers by periodically returning leadership to the "preferred" replica for each partition if it is available.</td>
    </tr>
    <tr>
      <td>leader.imbalance.per.broker.percentage</td>
      <td>10</td>
      <td>The percentage of leader imbalance allowed per broker. The controller will rebalance leadership if this ratio goes above
       the configured value per broker.</td>
    </tr>
    <tr>
      <td>leader.imbalance.check.interval.seconds</td>
      <td>300</td>
      <td>The frequency with which to check for leader imbalance.</td>
    </tr>
    <tr>
      <td>offset.metadata.max.bytes</td>
      <td>4096</td>
      <td>The maximum amount of metadata to allow clients to save with their offsets.</td>
    </tr>
    <tr>
      <td>max.connections.per.ip</td>
      <td>Int.MaxValue</td>
      <td>The maximum number of connections that a broker allows from each ip address.</td>
    </tr>
    <tr>
      <td>max.connections.per.ip.overrides</td>
      <td></td>
      <td>Per-ip or hostname overrides to the default maximum number of connections.</td>
    </tr>
    <tr>
      <td>connections.max.idle.ms</td>
      <td>600000</td>
      <td>Idle connections timeout: the server socket processor threads close the connections that idle more than this.</td>
    </tr>
    <tr>
      <td>log.roll.jitter.{ms,hours}</td>
      <td>0</td>
      <td>The maximum jitter to subtract from logRollTimeMillis.</td>
    </tr>
    <tr>
      <td>num.recovery.threads.per.data.dir</td>
      <td>1</td>
      <td>The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</td>
    </tr>
    <tr>
      <td>unclean.leader.election.enable</td>
      <td>true</td>
      <td>Indicates whether to enable replicas not in the ISR set to be elected as leader as a last resort, even though doing so may result in data loss.</td>
    </tr>
    <tr>
      <td>delete.topic.enable</td>
      <td>false</td>
      <td>Enable delete topic.</td>
    </tr>
    <tr>
      <td>offsets.topic.num.partitions</td>
      <td>50</td>
      <td>The number of partitions for the offset commit topic. Since changing this after deployment is currently unsupported, we recommend using a higher setting for production (e.g., 100-200).</td>
    </tr>
    <tr>
      <td>offsets.topic.retention.minutes</td>
      <td>1440</td>
      <td>Offsets that are older than this age will be marked for deletion. The actual purge will occur when the log cleaner compacts the offsets topic.</td>
    </tr>
    <tr>
      <td>offsets.retention.check.interval.ms</td>
      <td>600000</td>
      <td>The frequency at which the offset manager checks for stale offsets.</td>
    </tr>
    <tr>
      <td>offsets.topic.replication.factor</td>
      <td>3</td>
      <td>The replication factor for the offset commit topic. A higher setting (e.g., three or four) is recommended in order to ensure higher availability. If the offsets topic is created when fewer brokers than the replication factor then the offsets topic will be created with fewer replicas.</td>
    </tr>
    <tr>
      <td>offsets.topic.segment.bytes</td>
      <td>104857600</td>
      <td>Segment size for the offsets topic. Since it uses a compacted topic, this should be kept relatively low in order to facilitate faster log compaction and loads.</td>
    </tr>
    <tr>
      <td>offsets.load.buffer.size</td>
      <td>5242880</td>
      <td>An offset load occurs when a broker becomes the offset manager for a set of consumer groups (i.e., when it becomes a leader for an offsets topic partition). This setting corresponds to the batch size (in bytes) to use when reading from the offsets segments when loading offsets into the offset manager's cache.</td>
    </tr>
<!--
    <tr>
      <td>offsets.topic.compression.codec</td>
      <td>none</td>
      <td>(Should not be used until KAFKA-1374 is implemented.) Compression codec for the offsets topic. Compression should be enabled in order to achieve "atomic" commits.</td>
    </tr>
-->
    <tr>
      <td>offsets.commit.required.acks</td>
      <td>-1</td>
      <td>The number of acknowledgements that are required before the offset commit can be accepted. This is similar to the producer's acknowledgement setting. In general, the default should not be overridden.</td>
    </tr>
    <tr>
      <td>offsets.commit.timeout.ms</td>
      <td>5000</td>
      <td>The offset commit will be delayed until this timeout or the required number of replicas have received the offset commit. This is similar to the producer request timeout.</td>
    </tr>
    <tr>
      <td>inter.broker.protocol.version</td>
      <td>0.8.3</td>
      <td>Version of the protocol brokers will use to communicate with each other. This will default for the current version of the broker, but may need to be set to older versions during a rolling upgrade process. In that scenario, upgraded brokers will use the older version of the protocol and therefore will be able to communicate with brokers that were not yet upgraded. See <a href="#upgrade">upgrade section</a> for more details.</td>
    </tr>
</tbody></table>

<p>More details about broker configuration can be found in the scala class <code>kafka.server.KafkaConfig</code>.</p>

<h4><a id="topic-config">Topic-level configuration</a></h3>

Configurations pertinent to topics have both a global default as well an optional per-topic override. If no per-topic configuration is given the global default is used. The override can be set at topic creation time by giving one or more <code>--config</code> options. This example creates a topic named <i>my-topic</i> with a custom max message size and flush rate:
<pre>
<b> &gt; bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic my-topic --partitions 1
        --replication-factor 1 --config max.message.bytes=64000 --config flush.messages=1</b>
</pre>
Overrides can also be changed or set later using the alter topic command. This example updates the max message size for <i>my-topic</i>:
<pre>
<b> &gt; bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
    --config max.message.bytes=128000</b>
</pre>

To remove an override you can do
<pre>
<b> &gt; bin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic my-topic
    --deleteConfig max.message.bytes</b>
</pre>

The following are the topic-level configurations. The server's default configuration for this property is given under the Server Default Property heading, setting this default in the server config allows you to change the default given to topics that have no override specified.
<table class="data-table">
<tbody>
    <tr>
        <th>Property</th>
        <th>Default</th>
        <th>Server Default Property</th>
        <th>Description</th>
    </tr>
    <tr>
      <td>cleanup.policy</td>
      <td>delete</td>
      <td>log.cleanup.policy</td>
      <td>A string that is either "delete" or "compact". This string designates the retention policy to use on old log segments. The default policy ("delete") will discard old segments when their retention time or size limit has been reached. The "compact" setting will enable <a href="#compaction">log compaction</a> on the topic.</td>
    </tr>
    <tr>
      <td>delete.retention.ms</td>
      <td>86400000 (24 hours)</td>
      <td>log.cleaner.delete.retention.ms</td>
      <td>The amount of time to retain delete tombstone markers for <a href="#compaction">log compacted</a> topics. This setting also gives a bound on the time in which a consumer must complete a read if they begin from offset 0 to ensure that they get a valid snapshot of the final stage (otherwise delete tombstones may be collected before they complete their scan).</td>
    </tr>
    <tr>
      <td>flush.messages</td>
      <td>None</td>
      <td>log.flush.interval.messages</td>
      <td>This setting allows specifying an interval at which we will force an fsync of data written to the log. For example if this was set to 1 we would fsync after every message; if it were 5 we would fsync after every five messages. In general we recommend you not set this and use replication for durability and allow the operating system's background flush capabilities as it is more efficient. This setting can be overridden on a per-topic basis (see <a href="#topic-config">the per-topic configuration section</a>).</td>
    </tr>
    <tr>
      <td>flush.ms</td>
      <td>None</td>
      <td>log.flush.interval.ms</td>
      <td>This setting allows specifying a time interval at which we will force an fsync of data written to the log. For example if this was set to 1000 we would fsync after 1000 ms had passed. In general we recommend you not set this and use replication for durability and allow the operating system's background flush capabilities as it is more efficient.</td>
    </tr>
    <tr>
      <td>index.interval.bytes</td>
      <td>4096</td>
      <td>log.index.interval.bytes</td>
      <td>This setting controls how frequently Kafka adds an index entry to it's offset index. The default setting ensures that we index a message roughly every 4096 bytes. More indexing allows reads to jump closer to the exact position in the log but makes the index larger. You probably don't need to change this.</td>
    </tr>
    <tr>
      <td>max.message.bytes</td>
      <td>1,000,000</td>
      <td>message.max.bytes</td>
      <td>This is largest message size Kafka will allow to be appended to this topic. Note that if you increase this size you must also increase your consumer's fetch size so they can fetch messages this large.</td>
    </tr>
    <tr>
      <td>min.cleanable.dirty.ratio</td>
      <td>0.5</td>
      <td>log.cleaner.min.cleanable.ratio</td>
      <td>This configuration controls how frequently the log compactor will attempt to clean the log (assuming <a href="#compaction">log compaction</a> is enabled). By default we will avoid cleaning a log where more than 50% of the log has been compacted. This ratio bounds the maximum space wasted in the log by duplicates (at 50% at most 50% of the log could be duplicates). A higher ratio will mean fewer, more efficient cleanings but will mean more wasted space in the log.</td>
    </tr>
    <tr>
      <td>min.insync.replicas</td>
      <td>1</td>
      <td>min.insync.replicas</td>
      <td>When a producer sets request.required.acks to -1, min.insync.replicas specifies the minimum number of replicas that must acknowledge a write for the write to be considered successful. If this minimum cannot be met, then the producer will raise an exception (either NotEnoughReplicas or NotEnoughReplicasAfterAppend). </br>
      When used together, min.insync.replicas and request.required.acks allow you to enforce greater durability guarantees. A typical scenario would be to create a topic with a replication factor of 3, set min.insync.replicas to 2, and produce with request.required.acks of -1. This will ensure that the producer raises an exception if a majority of replicas do not receive a write.</td>
    </tr>
    <tr>
      <td>retention.bytes</td>
      <td>None</td>
      <td>log.retention.bytes</td>
      <td>This configuration controls the maximum size a log can grow to before we will discard old log segments to free up space if we are using the "delete" retention policy. By default there is no size limit only a time limit.</td>
    </tr>
    <tr>
      <td>retention.ms</td>
      <td>7 days</td>
      <td>log.retention.minutes</td>
      <td>This configuration controls the maximum time we will retain a log before we will discard old log segments to free up space if we are using the "delete" retention policy. This represents an SLA on how soon consumers must read their data.</td>
    </tr>
    <tr>
      <td>segment.bytes</td>
      <td>1 GB</td>
      <td>log.segment.bytes</td>
      <td>This configuration controls the segment file size for the log. Retention and cleaning is always done a file at a time so a larger segment size means fewer files but less granular control over retention.</td>
    </tr>
    <tr>
      <td>segment.index.bytes</td>
      <td>10 MB</td>
      <td>log.index.size.max.bytes</td>
      <td>This configuration controls the size of the index that maps offsets to file positions. We preallocate this index file and shrink it only after log rolls. You generally should not need to change this setting.</td>
    </tr>
    <tr>
      <td>segment.ms</td>
      <td>7 days</td>
      <td>log.roll.hours</td>
      <td>This configuration controls the period of time after which Kafka will force the log to roll even if the segment file isn't full to ensure that retention can delete or compact old data.</td>
    </tr>
    <tr>
      <td>segment.jitter.ms</td>
      <td>0</td>
      <td>log.roll.jitter.{ms,hours}</td>
      <td>The maximum jitter to subtract from logRollTimeMillis.</td>
    </tr>
</table>

<h3><a id="consumerconfigs">3.2 Consumer Configs</a></h3>
The essential consumer configurations are the following:
<ul>
        <li><code>group.id</code>
        <li><code>zookeeper.connect</code>
</ul>

<table class="data-table">
<tbody><tr>
        <th>Property</th>
        <th>Default</th>
        <th>Description</th>
</tr>
    <tr>
      <td>group.id</td>
      <td colspan="1"></td>
      <td>A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group.</td>
    </tr>
    <tr>
      <td>zookeeper.connect</td>
      <td colspan="1"></td>
          <td>Specifies the ZooKeeper connection string in the form <code>hostname:port</code> where host and port are the host and port of a ZooKeeper server. To allow connecting through other ZooKeeper nodes when that ZooKeeper machine is down you can also specify multiple hosts in the form <code>hostname1:port1,hostname2:port2,hostname3:port3</code>.
        <p>
    The server may also have a ZooKeeper chroot path as part of it's ZooKeeper connection string which puts its data under some path in the global ZooKeeper namespace. If so the consumer should use the same chroot path in its connection string. For example to give a chroot path of <code>/chroot/path</code> you would give the connection string as  <code>hostname1:port1,hostname2:port2,hostname3:port3/chroot/path</code>.</td>
    </tr>
    <tr>
      <td>consumer.id</td>
      <td colspan="1">null</td>
      <td>
        <p>Generated automatically if not set.</p>
     </td>
    </tr>
    <tr>
      <td>socket.timeout.ms</td>
      <td colspan="1">30 * 1000</td>
      <td>The socket timeout for network requests. The actual timeout set will be max.fetch.wait + socket.timeout.ms.</td>
    </tr>
    <tr>
      <td>socket.receive.buffer.bytes</td>
      <td colspan="1">64 * 1024</td>
      <td>The socket receive buffer for network requests</td>
    </tr>
    <tr>
      <td>fetch.message.max.bytes</td>
      <td nowrap>1024 * 1024</td>
      <td>The number of byes of messages to attempt to fetch for each topic-partition in each fetch request. These bytes will be read into memory for each partition, so this helps control the memory used by the consumer. The fetch request size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch.</td>
    </tr>
     <tr>
      <td>num.consumer.fetchers</td>
      <td colspan="1">1</td>
      <td>The number fetcher threads used to fetch data.</td>
    </tr>
    <tr>
      <td>auto.commit.enable</td>
      <td colspan="1">true</td>
      <td>If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.</td>
    </tr>
    <tr>
      <td>auto.commit.interval.ms</td>
      <td colspan="1">60 * 1000</td>
      <td>The frequency in ms that the consumer offsets are committed to zookeeper.</td>
    </tr>
    <tr>
      <td>queued.max.message.chunks</td>
      <td colspan="1">2</td>
      <td>Max number of message chunks buffered for consumption. Each chunk can be up to fetch.message.max.bytes.</td>
    </tr>
    <tr>
      <td>rebalance.max.retries</td>
      <td colspan="1">4</td>
      <td>When a new consumer joins a consumer group the set of consumers attempt to "rebalance" the load to assign partitions to each consumer. If the set of consumers changes while this assignment is taking place the rebalance will fail and retry. This setting controls the maximum number of attempts before giving up.</td>
    </tr>
    <tr>
      <td>fetch.min.bytes</td>
      <td colspan="1">1</td>
      <td>The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.</td>
    </tr>
    <tr>
      <td>fetch.wait.max.ms</td>
      <td colspan="1">100</td>
      <td>The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes</td>
    </tr>
    <tr>
      <td>rebalance.backoff.ms</td>
      <td>2000</td>
      <td>Backoff time between retries during rebalance.</td>
    </tr>
    <tr>
      <td>refresh.leader.backoff.ms</td>
      <td colspan="1">200</td>
      <td>Backoff time to wait before trying to determine the leader of a partition that has just lost its leader.</td>
    </tr>
    <tr>
      <td>auto.offset.reset</td>
      <td colspan="1">largest</td>
      <td>
        <p>What to do when there is no initial offset in ZooKeeper or if an offset is out of range:<br/>* smallest : automatically reset the offset to the smallest offset<br/>* largest : automatically reset the offset to the largest offset<br/>* anything else: throw exception to the consumer</p>
     </td>
    </tr>
    <tr>
      <td>consumer.timeout.ms</td>
      <td colspan="1">-1</td>
      <td>Throw a timeout exception to the consumer if no message is available for consumption after the specified interval</td>
    </tr>
     <tr>
      <td>exclude.internal.topics</td>
      <td colspan="1">true</td>
      <td>Whether messages from internal topics (such as offsets) should be exposed to the consumer.</td>
    </tr>
     <tr>
      <td>partition.assignment.strategy</td>
      <td colspan="1">range</td>
      <td>Select a strategy for assigning partitions to consumer streams. Possible values: range, roundrobin.</td>
    </tr>
    <tr>
      <td>client.id</td>
      <td colspan="1">group id value</td>
      <td>The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.</td>
    </tr>
    <tr>
      <td>zookeeper.session.timeout.ms </td>
      <td colspan="1">6000</td>
      <td>ZooKeeper session timeout. If the consumer fails to heartbeat to ZooKeeper for this period of time it is considered dead and a rebalance will occur.</td>
    </tr>
    <tr>
      <td>zookeeper.connection.timeout.ms</td>
      <td colspan="1">6000</td>
      <td>The max time that the client waits while establishing a connection to zookeeper.</td>
    </tr>
    <tr>
      <td>zookeeper.sync.time.ms </td>
      <td colspan="1">2000</td>
      <td>How far a ZK follower can be behind a ZK leader</td>
    </tr>
    <tr>
      <td>offsets.storage</td>
      <td colspan="1">zookeeper</td>
      <td>Select where offsets should be stored (zookeeper or kafka).</td>
    </tr>
    <tr>
      <td>offsets.channel.backoff.ms</td>
      <td colspan="1">1000</td>
      <td>The backoff period when reconnecting the offsets channel or retrying failed offset fetch/commit requests.</td>
    </tr>
    <tr>
      <td>offsets.channel.socket.timeout.ms</td>
      <td colspan="1">10000</td>
      <td>Socket timeout when reading responses for offset fetch/commit requests. This timeout is also used for ConsumerMetadata requests that are used to query for the offset manager.</td>
    </tr>
    <tr>
      <td>offsets.commit.max.retries</td>
      <td colspan="1">5</td>
      <td>Retry the offset commit up to this many times on failure. This retry count only applies to offset commits during shut-down. It does not apply to commits originating from the auto-commit thread. It also does not apply to attempts to query for the offset coordinator before committing offsets. i.e., if a consumer metadata request fails for any reason, it will be retried and that retry does not count toward this limit.</td>
    </tr>
    <tr>
      <td>dual.commit.enabled</td>
      <td colspan="1">true</td>
      <td>If you are using "kafka" as offsets.storage, you can dual commit offsets to ZooKeeper (in addition to Kafka). This is required during migration from zookeeper-based offset storage to kafka-based offset storage. With respect to any given consumer group, it is safe to turn this off after all instances within that group have been migrated to the new version that commits offsets to the broker (instead of directly to ZooKeeper).</td>
    </tr>
    <tr>
      <td>partition.assignment.strategy</td>
      <td colspan="1">range</td>
      <td><p>Select between the "range" or "roundrobin" strategy for assigning partitions to consumer streams.<p>The round-robin partition assignor lays out all the available partitions and all the available consumer threads. It then proceeds to do a round-robin assignment from partition to consumer thread. If the subscriptions of all consumer instances are identical, then the partitions will be uniformly distributed. (i.e., the partition ownership counts will be within a delta of exactly one across all consumer threads.) Round-robin assignment is permitted only if: (a) Every topic has the same number of streams within a consumer instance (b) The set of subscribed topics is identical for every consumer instance within the group.<p> Range partitioning works on a per-topic basis. For each topic, we lay out the available partitions in numeric order and the consumer threads in lexicographic order. We then divide the number of partitions by the total number of consumer streams (threads) to determine the number of partitions to assign to each consumer. If it does not evenly divide, then the first few consumers will have one extra partition.</td>
    </tr>
</tbody>
</table>


<p>More details about consumer configuration can be found in the scala class <code>kafka.consumer.ConsumerConfig</code>.</p>
<h3><a id="producerconfigs">3.3 Producer Configs</a></h3>
Essential configuration properties for the producer include:
<ul>
        <li><code>metadata.broker.list</code>
        <li><code>request.required.acks</code>
        <li><code>producer.type</code>
        <li><code>serializer.class</code>
</ul>

<table class="data-table">
<tbody><tr>
        <th>Property</th>
        <th>Default</th>
        <th>Description</th>
      </tr>
    <tr>
      <td>metadata.broker.list</td>
      <td colspan="1"></td>
      <td>
        <p>This is for bootstrapping and the producer will only use it for getting metadata (topics, partitions and replicas). The socket connections for sending the actual data will be established based on the broker information returned in the metadata. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers.</p>
     </td>
    </tr>
    <tr>
      <td>request.required.acks</td>
      <td colspan="1">0</td>
      <td>
        <p>This value controls when a produce request is considered completed. Specifically, how many other brokers must have committed the data to their log and acknowledged this to the leader? Typical values are
           <ul>
             <li>0, which means that the producer never waits for an acknowledgement from the broker (the same behavior as 0.7). This option provides the lowest latency but the weakest durability guarantees (some data will be lost when a server fails).
             <li> 1, which means that the producer gets an acknowledgement after the leader replica has received the data. This option provides better durability as the client waits until the server acknowledges the request as successful (only messages that were written to the now-dead leader but not yet replicated will be lost).
             <li>  -1, The producer gets an acknowledgement after all in-sync replicas have received the data. This option provides the greatest level of durability. However, it does not completely eliminate the risk of message loss because the number of in sync replicas may, in rare cases, shrink to 1. If you want to ensure that some minimum number of replicas (typically a majority) receive a write, then you must set the topic-level min.insync.replicas setting. Please read the Replication section of the design documentation for a more in-depth discussion.
            </ul>
        </p>
     </td>
    </tr>
    <tr>
      <td>request.timeout.ms</td>
      <td colspan="1">10000</td>
      <td>The amount of time the broker will wait trying to meet the request.required.acks requirement before sending back an error to the client.</td>
    </tr>
    <tr>
      <td>producer.type</td>
      <td colspan="1">sync</td>
      <td>
        <p>This parameter specifies whether the messages are sent asynchronously in a background thread. Valid values are (1) async for asynchronous send and (2) sync for synchronous send. By setting the producer to async we allow batching together of requests (which is great for throughput) but open the possibility of a failure of the client machine dropping unsent data.</p>
     </td>
    <tr>
      <td>serializer.class</td>
      <td colspan="1">kafka.serializer.DefaultEncoder</td>
      <td>The serializer class for messages. The default encoder takes a byte[] and returns the same byte[].</td>
    </tr>
    <tr>
      <td>key.serializer.class</td>
      <td colspan="1"></td>
      <td>The serializer class for keys (defaults to the same as for messages if nothing is given).</td>
    </tr>
    <tr>
      <td>partitioner.class</td>
      <td colspan="1">kafka.producer.DefaultPartitioner</td>
      <td>The partitioner class for partitioning messages amongst sub-topics. The default partitioner is based on the hash of the key.</td>
    </tr>
    <tr>
      <td>compression.codec</td>
      <td colspan="1">none</td>
      <td>
        <p>This parameter allows you to specify the compression codec for all data generated by this producer. Valid values are "none", "gzip" and "snappy".</p>
     </td>
    </tr>
    <tr>
      <td>compressed.topics</td>
      <td colspan="1">null</td>
      <td>
        <p>This parameter allows you to set whether compression should be turned on for particular topics. If the compression codec is anything other than NoCompressionCodec, enable compression only for specified topics if any. If the list of compressed topics is empty, then enable the specified compression codec for all topics. If the compression codec is NoCompressionCodec, compression is disabled for all topics</p>
     </td>
    </tr>
    <tr>
      <td>message.send.max.retries</td>
      <td colspan="1">3</td>
      <td>
        <p>This property will cause the producer to automatically retry a failed send request. This property specifies the number of retries when such failures occur. Note that setting a non-zero value here can lead to duplicates in the case of network errors that cause a message to be sent but the acknowledgement to be lost.</p>
     </td>
    </tr>
    <tr>
      <td>retry.backoff.ms</td>
      <td colspan="1">100</td>
      <td>
        <p>Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected. Since leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata.</p>
     </td>
    </tr>
    <tr>
      <td>topic.metadata.refresh.interval.ms</td>
      <td colspan="1">600 * 1000</td>
      <td>
        <p>The producer generally refreshes the topic metadata from brokers when there is a failure (partition missing, leader not available...). It will also poll regularly (default: every 10min so 600000ms). If you set this to a negative value, metadata will only get refreshed on failure. If you set this to zero, the metadata will get refreshed after each message sent (not recommended). Important note: the refresh happen only AFTER the message is sent, so if the producer never sends a message the metadata is never refreshed</p>
     </td>
    </tr>
    <tr>
      <td>queue.buffering.max.ms</td>
      <td colspan="1">5000</td>
      <td>Maximum time to buffer data when using async mode. For example a setting of 100 will try to batch together 100ms of messages to send at once. This will improve throughput but adds message delivery latency due to the buffering.</td>
    </tr>
    <tr>
      <td>queue.buffering.max.messages</td>
      <td colspan="1">10000</td>
      <td>The maximum number of unsent messages that can be queued up the producer when using async mode before either the producer must be blocked or data must be dropped.</td>
    </tr>
    <tr>
      <td>queue.enqueue.timeout.ms</td>
      <td colspan="1">-1</td>
      <td>
        <p>The amount of time to block before dropping messages when running in async mode and the buffer has reached queue.buffering.max.messages. If set to 0 events will be enqueued immediately or dropped if the queue is full (the producer send call will never block). If set to -1 the producer will block indefinitely and never willingly drop a send.</p>
     </td>
    </tr>
    <tr>
      <td>batch.num.messages</td>
      <td colspan="1">200</td>
      <td>The number of messages to send in one batch when using async mode. The producer will wait until either this number of messages are ready to send or queue.buffer.max.ms is reached.</td>
    </tr>
    <tr>
      <td>send.buffer.bytes</td>
      <td colspan="1">100 * 1024</td>
      <td>Socket write buffer size</td>
    </tr>
    <tr>
      <td>client.id</td>
      <td colspan="1">""</td>
      <td>The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.</td>
    </tr>
</tbody></table>
<p>More details about producer configuration can be found in the scala class <code>kafka.producer.ProducerConfig</code>.</p>

<h3><a id="newproducerconfigs">3.4 New Producer Configs</a></h3>

We are working on a replacement for our existing producer. The code is available in trunk now and can be considered beta quality. Below is the configuration for the new producer.

<table class="data-table">
	<tr>
	<th>Name</th>
	<th>Type</th>
	<th>Default</th>
	<th>Importance</th>
	<th>Description</th>
	</tr>
	<tr>
	<td>bootstrap.servers</td><td>list</td><td></td><td>high</td><td>A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. Data will be load balanced over all servers irrespective of which servers are specified here for bootstrapping&mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form <code>host1:port1,host2:port2,...</code>. Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down). If no server in this list is available sending data will fail until on becomes available.</td></tr>
	<tr>
	<td>acks</td><td>string</td><td>1</td><td>high</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the  durability of records that are sent. The following settings are common:  <ul> <li><code>acks=0</code> If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the <code>retries</code> configuration will not take effect (as the client won't generally know of any failures). The offset given back for each record will always be set to -1. <li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost. <li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. <li>Other settings such as <code>acks=2</code> are also possible, and will require the given number of acknowledgements but this is generally less useful.</td></tr>
	<tr>
	<td>buffer.memory</td><td>long</td><td>33554432</td><td>high</td><td>The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are sent faster than they can be delivered to the server the producer will either block or throw an exception based on the preference specified by <code>block.on.buffer.full</code>. <p>This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if compression is enabled) as well as for maintaining in-flight requests.</td></tr>
	<tr>
	<td>compression.type</td><td>string</td><td>none</td><td>high</td><td>The compression type for all data generated by the producer. The default is none (i.e. no compression). Valid  values are <code>none</code>, <code>gzip</code>, or <code>snappy</code>. Compression is of full batches of data,  so the efficacy of batching will also impact the compression ratio (more batching means better compression).</td></tr>
	<tr>
	<td>retries</td><td>int</td><td>0</td><td>high</td><td>Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. Note that this retry is no different than if the client resent the record upon receiving the error. Allowing retries will potentially change the ordering of records because if two records are sent to a single partition, and the first fails and is retried but the second succeeds, then the second record may appear first.</td></tr>
	<tr>
	<td>key.serializer</td><td>string</td><td></td><td>high</td><td>The serializer class for keys. The provided class must implement <code>org.apache.kafka.common.serialization.Serializer</code>. Default implementations are available in <code>org.apache.kafka.common.serialization</code>.</td></tr>
	<tr>
	<td>value.serializer</td><td>string</td><td></td><td>high</td><td>The serializer class for messages. The provided class must implement <code>org.apache.kafka.common.serialization.Serializer</code>. Default implementations are available in <code>org.apache.kafka.common.serialization</code>.</td></tr>
	<tr>
	<td>batch.size</td><td>int</td><td>16384</td><td>medium</td><td>The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition. This helps performance on both the client and the server. This configuration controls the default batch size in bytes. <p>No attempt will be made to batch records larger than this size. <p>Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent. <p>A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a buffer of the specified batch size in anticipation of additional records.</td></tr>
	<tr>
	<td>client.id</td><td>string</td><td></td><td>medium</td><td>The id string to pass to the server when making requests. The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical application name to be included with the request. The application can set any string it wants as this has no functional purpose other than in logging and metrics.</td></tr>
	<tr>
	<td>linger.ms</td><td>long</td><td>0</td><td>medium</td><td>The producer groups together any records that arrive in between request transmissions into a single batched request. Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount of artificial delay&mdash;that is, rather than immediately sending out a record the producer will wait for up to the given delay to allow other records to be sent so that the sends can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get <code>batch.size</code> worth of records for a partition it will be sent immediately regardless of this setting, however if we have fewer than this many bytes accumulated for this partition we will 'linger' for the specified time waiting for more records to show up. This setting defaults to 0 (i.e. no delay). Setting <code>linger.ms=5</code>, for example, would have the effect of reducing the number of requests sent but would add up to 5ms of latency to records sent in the absense of load.</td></tr>
	<tr>
	<td>max.request.size</td><td>int</td><td>1048576</td><td>medium</td><td>The maximum size of a request. This is also effectively a cap on the maximum record size. Note that the server has its own cap on record size which may be different from this. This setting will limit the number of record batches the producer will send in a single request to avoid sending huge requests.</td></tr>
	<tr>
	<td>receive.buffer.bytes</td><td>int</td><td>32768</td><td>medium</td><td>The size of the TCP receive buffer to use when reading data</td></tr>
	<tr>
	<td>send.buffer.bytes</td><td>int</td><td>131072</td><td>medium</td><td>The size of the TCP send buffer to use when sending data</td></tr>
	<tr>
	<td>timeout.ms</td><td>int</td><td>30000</td><td>medium</td><td>The configuration controls the maximum amount of time the server will wait for acknowledgments from followers to meet the acknowledgment requirements the producer has specified with the <code>acks</code> configuration. If the requested number of acknowledgments are not met when the timeout elapses an error will be returned. This timeout is measured on the server side and does not include the network latency of the request.</td></tr>
	<tr>
	<td>block.on.buffer.full</td><td>boolean</td><td>true</td><td>low</td><td>When our memory buffer is exhausted we must either stop accepting new records (block) or throw errors. By default this setting is true and we block, however in some scenarios blocking is not desirable and it is better to immediately give an error. Setting this to <code>false</code> will accomplish that: the producer will throw a BufferExhaustedException if a recrord is sent and the buffer space is full.</td></tr>
	<tr>
	<td>metadata.fetch.timeout.ms</td><td>long</td><td>60000</td><td>low</td><td>The first time data is sent to a topic we must fetch metadata about that topic to know which servers host the topic's partitions. This configuration controls the maximum amount of time we will block waiting for the metadata fetch to succeed before throwing an exception back to the client.</td></tr>
	<tr>
	<td>metadata.max.age.ms</td><td>long</td><td>300000</td><td>low</td><td>The period of time in milliseconds after which we force a refresh of metadata even if we haven't seen any  partition leadership changes to proactively discover any new brokers or partitions.</td></tr>
	<tr>
	<td>metric.reporters</td><td>list</td><td>[]</td><td>low</td><td>A list of classes to use as metrics reporters. Implementing the <code>MetricReporter</code> interface allows plugging in classes that will be notified of new metric creation. The JmxReporter is always included to register JMX statistics.</td></tr>
	<tr>
	<td>metrics.num.samples</td><td>int</td><td>2</td><td>low</td><td>The number of samples maintained to compute metrics.</td></tr>
	<tr>
	<td>metrics.sample.window.ms</td><td>long</td><td>30000</td><td>low</td><td>The metrics system maintains a configurable number of samples over a fixed window size. This configuration controls the size of the window. For example we might maintain two samples each measured over a 30 second period. When a window expires we erase and overwrite the oldest window.</td></tr>
	<tr>
	<td>reconnect.backoff.ms</td><td>long</td><td>10</td><td>low</td><td>The amount of time to wait before attempting to reconnect to a given host when a connection fails. This avoids a scenario where the client repeatedly attempts to connect to a host in a tight loop.</td></tr>
	<tr>
	<td>retry.backoff.ms</td><td>long</td><td>100</td><td>low</td><td>The amount of time to wait before attempting to retry a failed produce request to a given topic partition. This avoids repeated sending-and-failing in a tight loop.</td></tr>
	<tr>
	<td>max.in.flight.requests.per.connection</td><td>int</td><td>5</td><td>low</td><td>The number of "in-flight requests" on a given connection is the number of requests currently awaiting acknowledgement on that connection. When the number of in-flight requests is equal to this number, the client will wait for one of them to be acknowledged before sending the next request to that node. It's important to note that one request corresponds to a batch of messages, so increasing this number too much can cause suboptimal batching behavior in the client. This is because the client will not wait long enough to let messages batch together into large batches, and will instead send many small requests which are much less efficient to process. You can explicitly instruct the client to wait a certain amount of time until more messages are available to batch by setting <code>linger.ms</code>. In addition, setting this number high increase throughput but can cause out-of-order message arrivals.</td></tr>
	</table>
